/* ============================================================
 * node-huobi-api
 * https://github.com/yosiet/node-huobi-api
 * ============================================================
 * Copyright 2017-, Yosiet Serga
 * Released under the MIT License
 * ============================================================ */

/**
 * Node Huobi API
 * @module yosiet/node-huobi-api
 * @return {object} instance to class object
 */
let api = function Huobi() {
    let App = this; // eslint-disable-line consistent-this
    'use strict'; // eslint-disable-line no-unused-expressions
    const WebSocket = require('ws');
    const request = require('request');
	const moment = require('moment');
	const CryptoJS = require('crypto-js');
	const HmacSHA256 = require('crypto-js/hmac-sha256')
    const file = require('fs');
    const url = require('url');
    const HttpsProxyAgent = require('https-proxy-agent');
    const SocksProxyAgent = require('socks-proxy-agent');
    const stringHash = require('string-hash');
    const async = require('async');
    const pako = require('pako');
    const base = 'https://api.huobi.pro/';
    const hostname = 'api.huobi.pro';
    const stream = 'wss://api.huobi.pro/hbus/ws/';
    const combineStream = 'wss://stream.binance.com:9443/stream?streams=';
    const userAgent = 'Mozilla/4.0 (compatible; Node Huobi API)';
    const contentType = 'application/x-www-form-urlencoded';

    App.subscriptions = {};
    App.depthCache = {};
    App.depthCacheContext = {};
    App.ohlcLatest = {};
    App.klineQueue = {};
    App.ohlc = {};

    const default_options = {
        reconnect: true,
        log: function (...args) {
            console.log(Array.prototype.slice.call(args));
        }
    };

    App.options = default_options;
    App.info = { timeOffset: 0 };
    App.socketHeartbeatInterval = null;

    const log = App.options.log;

    /**
     * Checks to see of the object is iterable
     * @param {object} obj - The object check
     * @return {boolean} true or false is iterable
     */
    const isIterable = function (obj) {
        // checks for null and undefined
        if (obj === null) {
            return false;
        }
        return typeof obj[Symbol.iterator] === 'function';
    }

    const reqHandler = cb => (error, response, body) => {
        if (!cb) return;

        if (error) return cb(error, {});

        if (response && response.statusCode !== 200) return cb(response, {});

        return cb(null, JSON.parse(body));
    }

    const addProxy = opt => {
        return opt;
    }

    const proxyRequest = (opt, cb) => request(addProxy(opt), reqHandler(cb));

    const reqObj = (endpoint, data = {}, method = 'GET', key) => ({
        url: base + endpoint,
        qs: data,
        method: method,
        timeout: App.options.recvWindow,
        headers: {
            'User-Agent': userAgent,
            'Content-type': contentType,
            'X-MBX-APIKEY': key || ''
        }
    })
    const reqObjPOST = (endpoint, data = {}, method = 'POST', key) => ({
        url: base + endpoint,
        form: data,
        method: method,
        timeout: App.options.recvWindow,
        headers: {
            'User-Agent': userAgent,
            'Content-type': contentType,
            'X-MBX-APIKEY': key || ''
        }
    })
    /**
     * Create a http request to the public API
     * @param {string} url - The http endpoint
     * @param {object} data - The data to send
     * @param {function} callback - The callback method to call
     * @param {string} method - the http method
     * @return {undefined}
     */
    const publicRequest = function (endpoint, data = {}, callback, method = 'GET') {
        //let opt = reqObj(base + endpoint, data, method);log(opt);
        let opt = reqObj(endpoint, data, method);log(opt);
        proxyRequest(opt, callback);
    };

    /**
     * Create a http request to the public API
     * @param {string} url - The http endpoint
     * @param {object} data - The data to send
     * @param {function} callback - The callback method to call
     * @param {string} method - the http method
     * @return {undefined}
     */
    const apiRequest = function (endpoint, data = {}, callback, method = 'GET') {
        if (!App.options.APIKEY) throw Error('apiRequest: Invalid API Key');
        let opt = reqObj(
            endpoint,
            data,
            method,
            App.options.APIKEY
        );
        proxyRequest(opt, callback);
    };

    /**
     * Make market request
     * @param {string} url - The http endpoint
     * @param {object} data - The data to send
     * @param {function} callback - The callback method to call
     * @param {string} method - the http method
     * @return {undefined}
     */
    const marketRequest = function (endpoint, data = {}, callback, method = 'GET') {
        if (!App.options.APIKEY) throw Error('apiRequest: Invalid API Key');
        let query = Object.keys(data).reduce(function (a, k) {
            a.push(k + '=' + encodeURIComponent(data[k]));
            return a;
        }, []).join('&');

        let opt = reqObj(
            endpoint + (query ? '?' + query : ''),
            data,
            method,
            App.options.APIKEY
        );
        proxyRequest(opt, callback);
    };

    /**
     * Create a signed http request to the signed API
     * @param {string} url - The http endpoint
     * @param {object} data - The data to send
     * @param {function} callback - The callback method to call
     * @param {string} method - the http method
     * @return {undefined}
     */
	function get_signed_query(method, endpoint, data) {
	    var pars = [];

	    for (let item in data) {
	        pars.push(item + "=" + encodeURIComponent(data[item]));
	    }

	    var p 		= pars.sort().join("&");
	    var meta 	= [method, hostname, '/'+endpoint, p].join('\n');
	    var hash 	= HmacSHA256(meta, App.options.APISECRET);
	    var Signature = encodeURIComponent(CryptoJS.enc.Base64.stringify(hash));

	    return `${p}&Signature=${Signature}`;
	}

    const signedRequest = function (endpoint, data = {}, callback, method = 'GET') {
        if (!App.options.APIKEY) throw Error('apiRequest: Invalid API Key');
        if (!App.options.APISECRET) throw Error('signedRequest: Invalid API Secret');

		data.AccessKeyId = App.options.APIKEY;
		data.Timestamp = moment.utc().format('YYYY-MM-DDTHH:mm:ss');
		if (typeof data.SignatureMethod == 'undefined') data.SignatureMethod = "HmacSHA256";
		if (typeof data.SignatureVersion == 'undefined') data.SignatureVersion = 2;

        let query = get_signed_query(method, endpoint, data);

        if (method === 'POST') {
            let opt = reqObjPOST(
                endpoint + '?Signature=' + signature,
                data,
                method,
                App.options.APIKEY
            );
            proxyRequest(opt, callback);
        } else {
            let opt = reqObj(
                endpoint + '?' + query,
                data,
                method,
                App.options.APIKEY
            );
            proxyRequest(opt, callback);
        }
    };

    /**
     * Create a signed http request to the signed API
     * @param {string} side - BUY or SELL
     * @param {string} symbol - The symbol to buy or sell
     * @param {string} quantity - The quantity to buy or sell
     * @param {string} price - The price per unit to transact each unit at
     * @param {object} flags - additional order settings
     * @param {function} callback - the callback function
     * @return {undefined}
     */
    const order = function (side, symbol, amount, price, flags = {}, callback = false) {
        let endpoint = 'v1/order/orders/place';

        let opt = {
            symbol,
            side,
            type: side.toLowerCase() +'-limit',
            amount
        };

        /*
        trade types:
        buy-market, 
        buy-limit, 
        buy-ioc, 
        buy-limit-maker, 
        buy-stop-limit, 

        sell-market, 
        sell-limit, 
        sell-ioc, 
        sell-limit-maker, 
        sell-stop-limit
        */
       
        if (typeof flags.type !== 'undefined') opt.type = flags.type;

        if (opt.type.includes('limit')) {
            opt.price = price;
            opt.timeInForce = 'GTC';
        }

        if (typeof flags.timeInForce !== 'undefined') opt.timeInForce = flags.timeInForce;
        if (typeof flags.newOrderRespType !== 'undefined') opt.newOrderRespType = flags.newOrderRespType;
        if (typeof flags.newClientOrderId !== 'undefined') opt.newClientOrderId = flags.newClientOrderId;

        if (typeof flags.icebergQty !== 'undefined') opt.icebergQty = flags.icebergQty;

        if (typeof flags.stopPrice !== 'undefined') {
            opt.stopPrice = flags.stopPrice;
            if (!opt.type.includes('stop')) throw Error('stopPrice: Must set "type" to one of the following: buy-stop-limit, sell-stop-limit, buy-limit-maker, sell-limit-maker');
        }

        signedRequest(endpoint, opt, function (error, response) {
            if (!response) {
                if (callback) callback(error, response);
                else log('Order() error:', error);
                return;
            }

            if (typeof response.msg !== 'undefined' && response.msg === 'Filter failure: MIN_NOTIONAL') {
                log('Order quantity too small. See exchangeInfo() for minimum amounts');
            }

            if (callback) callback(error, response);
            else log(side + '(' + symbol + ',' + quantity + ',' + price + ') ', response);
        }, 'POST');
    };

    /**
     * No-operation function
     * @return {undefined}
     */
    const noop = function () {
        // do nothing
    };

    /**
     * Reworked Tuitio's heartbeat code into a shared single interval tick
     * @return {undefined}
     */
    const socketHeartbeat = function () {

        /* sockets removed from `subscriptions` during a manual terminate()
           will no longer be at risk of having functions called on them */
        for (let endpointId in App.subscriptions) {
            const ws = App.subscriptions[endpointId];
            if (ws.isAlive) {
                ws.isAlive = false;
                if (ws.readyState === WebSocket.OPEN) ws.ping(noop);
            } else {
                if (App.options.verbose) log('Terminating inactive/broken WebSocket: ' + ws.endpoint);
                if (ws.readyState === WebSocket.OPEN) ws.terminate();
            }
        }
    };

    /**
     * Called when socket is opened, subscriptions are registered for later reference
     * @param {function} opened_callback - a callback function
     * @return {undefined}
     */
    const handleSocketOpen = function (opened_callback) {
        this.isAlive = true;
        if (Object.keys(App.subscriptions).length === 0) {
            App.socketHeartbeatInterval = setInterval(socketHeartbeat, 30000);
        }
        App.subscriptions[this.endpoint] = this;
        if (typeof opened_callback === 'function') opened_callback(this.endpoint);
    };

    /**
     * Called when socket is closed, subscriptions are de-registered for later reference
     * @param {boolean} reconnect - true or false to reconnect the socket
     * @param {string} code - code associated with the socket
     * @param {string} reason - string with the response
     * @return {undefined}
     */
    const handleSocketClose = function (reconnect, code, reason) {
        delete App.subscriptions[this.endpoint];
        if (App.subscriptions && Object.keys(App.subscriptions).length === 0) {
            clearInterval(App.socketHeartbeatInterval);
        }
        log('WebSocket closed: ' + this.endpoint +
            (code ? ' (' + code + ')' : '') +
            (reason ? ' ' + reason : ''));
        if (App.options.reconnect && this.reconnect && reconnect) {
            if (this.endpoint && parseInt(this.endpoint.length, 10) === 60) log('Account data WebSocket reconnecting...');
            else log('WebSocket reconnecting: ' + this.endpoint + '...');
            try {
                reconnect();
            } catch (error) {
                log('WebSocket reconnect error: ' + error.message);
            }
        }
    };

    /**
     * Called when socket errors
     * @param {object} error - error object message
     * @return {undefined}
     */
    const handleSocketError = function (error) {
        /* Errors ultimately result in a `close` event.
           see: https://github.com/websockets/ws/blob/828194044bf247af852b31c49e2800d557fedeff/lib/websocket.js#L126 */
        log('WebSocket error: ' + this.endpoint +
            (error.code ? ' (' + error.code + ')' : '') +
            (error.message ? ' ' + error.message : ''));
    };

    /**
     * Called on each socket heartbeat
     * @return {undefined}
     */
    const handleSocketHeartbeat = function () {
        this.isAlive = true;
    };

    /**
     * Used to subscribe to a single websocket endpoint
     * @param {string} endpoint - endpoint to connect to
     * @param {function} callback - the function to called when information is received
     * @param {boolean} reconnect - whether to reconnect on disconnect
     * @param {object} opened_callback - the function to called when opened
     * @return {WebSocket} - websocket reference
     */
    const subscribe = function (endpoint, callback, reconnect = false, opened_callback = false) {

        let httpsproxy = process.env.https_proxy || false;
        let socksproxy = process.env.socks_proxy || false;
        let ws = false;

        if (socksproxy !== false) {
            socksproxy = proxyReplacewithIp(socksproxy);
            if (App.options.verbose) log('using socks proxy server ' + socksproxy);
            let agent = new SocksProxyAgent({
                protocol: parseProxy(socksproxy)[0],
                host: parseProxy(socksproxy)[1],
                port: parseProxy(socksproxy)[2]
            });
            ws = new WebSocket(stream + endpoint, { agent: agent });
        } else if (httpsproxy !== false) {
            if (App.options.verbose) log('using proxy server ' + agent);
            let config = url.parse(httpsproxy);
            let agent = new HttpsProxyAgent(config);
            ws = new WebSocket(stream + endpoint, { agent: agent });
        } else {
            ws = new WebSocket(stream + endpoint);
        }

        if (App.options.verbose) log('Subscribed to ' + endpoint);
        ws.reconnect = App.options.reconnect;
        ws.endpoint = endpoint;
        ws.isAlive = false;
        ws.on('open', handleSocketOpen.bind(ws, opened_callback));
        ws.on('pong', handleSocketHeartbeat);
        ws.on('error', handleSocketError);
        ws.on('close', handleSocketClose.bind(ws, reconnect));
        ws.on('message', function (data) {
            try {
                let text = pako.inflate(data, {
                    to: 'string'
                });
                callback(JSON.parse(text));
            } catch (error) {
                log('Parse error: ' + error.message);
            }
        });
        return ws;
    };

    /**
     * Used to subscribe to a combined websocket endpoint
     * @param {string} streams - streams to connect to
     * @param {function} callback - the function to called when information is received
     * @param {boolean} reconnect - whether to reconnect on disconnect
     * @param {object} opened_callback - the function to called when opened
     * @return {WebSocket} - websocket reference
     */
    const subscribeCombined = function (streams, callback, reconnect = false, opened_callback = false) {

        let httpsproxy = process.env.https_proxy || false;
        let socksproxy = process.env.socks_proxy || false;
        const queryParams = streams.join('/');
        let ws = false;

        if (socksproxy !== false) {
            socksproxy = proxyReplacewithIp(socksproxy);
            if (App.options.verbose) log('using socks proxy server ' + socksproxy);
            let agent = new SocksProxyAgent({
                protocol: parseProxy(socksproxy)[0],
                host: parseProxy(socksproxy)[1],
                port: parseProxy(socksproxy)[2]
            });
            ws = new WebSocket(combineStream + queryParams, { agent: agent });
        } else if (httpsproxy !== false) {
            if (App.options.verbose) log('using proxy server ' + httpsproxy);
            let config = url.parse(httpsproxy);
            let agent = new HttpsProxyAgent(config);
            ws = new WebSocket(combineStream + queryParams, { agent: agent });
        } else {
            ws = new WebSocket(combineStream + queryParams);
        }

        ws.reconnect = App.options.reconnect;
        ws.endpoint = stringHash(queryParams);
        ws.isAlive = false;
        if (App.options.verbose) {
            log('CombinedStream: Subscribed to [' + ws.endpoint + '] ' + queryParams);
        }
        ws.on('open', handleSocketOpen.bind(ws, opened_callback));
        ws.on('pong', handleSocketHeartbeat);
        ws.on('error', handleSocketError);
        ws.on('close', handleSocketClose.bind(ws, reconnect));
        ws.on('message', function (data) {
            try {
                let text = pako.inflate(data, {
                    to: 'string'
                });
                callback(JSON.parse(text).data);
            } catch (error) {
                log('CombinedStream: Parse error: ' + error.message);
            }
        });
        return ws;
    };

    /**
     * Used to terminate a web socket
     * @param {string} endpoint - endpoint identifier associated with the web socket
     * @param {boolean} reconnect - auto reconnect after termination
     * @return {undefined}
     */
    const terminate = function (endpoint, reconnect = false) {
        let ws = App.subscriptions[endpoint];
        if (!ws) return;
        ws.removeAllListeners('message');
        ws.reconnect = reconnect;
        ws.terminate();
    }

    /**
     * Used as part of the user data websockets callback
     * @param {object} data - user data callback data type
     * @return {undefined}
     */
    const userDataHandler = function (data) {
        let type = data.e;
        if (type === 'outboundAccountInfo') {
            App.options.balance_callback(data);
        } else if (type === 'executionReport') {
            if (App.options.execution_callback) App.options.execution_callback(data);
        } else {
            log('Unexpected userData: ' + type);
        }
    };

    /**
     * Gets the price of a given symbol or symbols
     * @param {array} data - array of symbols
     * @return {array} - symbols with their current prices
     */
    const priceData = function (data) {
        const prices = {};
        if (Array.isArray(data)) {
            for (let obj of data) {
                prices[obj.symbol] = obj.price;
            }
        } else { // Single price returned
            prices[data.symbol] = data.price;
        }
        return prices;
    };

    /**
     * Used by bookTickers to format the bids and asks given given symbols
     * @param {array} data - array of symbols
     * @return {object} - symbols with their bids and asks data
     */
    const bookPriceData = function (data) {
        let prices = {};
        for (let obj of data) {
            prices[obj.symbol] = {
                bid: obj.bidPrice,
                bids: obj.bidQty,
                ask: obj.askPrice,
                asks: obj.askQty
            };
        }
        return prices;
    };

    /**
     * Used by balance to get the balance data
     * @param {array} data - account info object
     * @return {object} - balances hel with available, onorder amounts
     */
    const balanceData = function (data) {
        let balances = {};
        if (typeof data === 'undefined') return {};
        if (typeof data.balances === 'undefined') {
            log('balanceData error', data);
            return {};
        }
        for (let obj of data.balances) {
            balances[obj.asset] = { available: obj.free, onOrder: obj.locked };
        }
        return balances;
    };

    /**
     * Used by web sockets depth and populates OHLC and info
     * @param {string} symbol - symbol to get candlestick info
     * @param {string} interval - time interval, 1m, 3m, 5m ....
     * @param {array} ticks - tick array
     * @return {undefined}
     */
    const klineData = function (symbol, interval, ticks) { // Used for /depth
        let last_time = 0;
        if (isIterable(ticks)) {
            for (let tick of ticks) {
                // eslint-disable-next-line no-unused-vars
                let [time, open, high, low, close, volume, closeTime, assetVolume, trades, buyBaseVolume, buyAssetVolume, ignored] = tick;
                App.ohlc[symbol][interval][time] = { open: open, high: high, low: low, close: close, volume: volume };
                last_time = time;
            }

            App.info[symbol][interval].timestamp = last_time;
        }
    };

    /**
     * Combines all OHLC data with latest update
     * @param {string} symbol - the symbol
     * @param {string} interval - time interval, 1m, 3m, 5m ....
     * @return {array} - interval data for given symbol
     */
    const klineConcat = function (symbol, interval) {
        let output = App.ohlc[symbol][interval];
        if (typeof App.ohlcLatest[symbol][interval].time === 'undefined') return output;
        const time = App.ohlcLatest[symbol][interval].time;
        const last_updated = Object.keys(App.ohlc[symbol][interval]).pop();
        if (time >= last_updated) {
            output[time] = App.ohlcLatest[symbol][interval];
            delete output[time].time;
            output[time].isFinal = false;
        }
        return output;
    };

    /**
     * Used for websocket @kline
     * @param {string} symbol - the symbol
     * @param {object} kline - object with kline info
     * @param {string} firstTime - time filter
     * @return {undefined}
     */
    const klineHandler = function (symbol, kline, firstTime = 0) {
        // TODO: add Taker buy base asset volume
        // eslint-disable-next-line no-unused-vars
        let { e: eventType, E: eventTime, k: ticks } = kline;
        // eslint-disable-next-line no-unused-vars
        let { o: open, h: high, l: low, c: close, v: volume, i: interval, x: isFinal, q: quoteVolume, t: time } = ticks; //n:trades, V:buyVolume, Q:quoteBuyVolume
        if (time <= firstTime) return;
        if (!isFinal) {
            if (typeof App.ohlcLatest[symbol][interval].time !== 'undefined') {
                if (App.ohlcLatest[symbol][interval].time > time) return;
            }
            App.ohlcLatest[symbol][interval] = { open: open, high: high, low: low, close: close, volume: volume, time: time };
            return;
        }
        // Delete an element from the beginning so we don't run out of memory
        const first_updated = Object.keys(App.ohlc[symbol][interval]).shift();
        if (first_updated) delete App.ohlc[symbol][interval][first_updated];
        App.ohlc[symbol][interval][time] = { open: open, high: high, low: low, close: close, volume: volume };
    };

    /**
     * Used for /depth endpoint
     * @param {object} data - containing the bids and asks
     * @return {undefined}
     */
    const depthData = function (data) {
        if (!data) return { bids: [], asks: [] };
        let bids = {}, asks = {}, obj;
        if (typeof data.bids !== 'undefined') {
            for (obj of data.bids) {
                bids[obj[0]] = parseFloat(obj[1]);
            }
        }
        if (typeof data.asks !== 'undefined') {
            for (obj of data.asks) {
                asks[obj[0]] = parseFloat(obj[1]);
            }
        }
        return { lastUpdateId: data.lastUpdateId, bids: bids, asks: asks };
    }

    /**
     * Used for /depth endpoint
     * @param {object} depth - information
     * @return {undefined}
     */
    const depthHandler = function (depth) {
        let symbol = depth.s, obj;
        let context = App.depthCacheContext[symbol];

        let updateDepthCache = function () {
            App.depthCache[symbol].eventTime = depth.E;
            for (obj of depth.b) { //bids
                if (obj[1] === '0.00000000') {
                    delete App.depthCache[symbol].bids[obj[0]];
                } else {
                    App.depthCache[symbol].bids[obj[0]] = parseFloat(obj[1]);
                }
            }
            for (obj of depth.a) { //asks
                if (obj[1] === '0.00000000') {
                    delete App.depthCache[symbol].asks[obj[0]];
                } else {
                    App.depthCache[symbol].asks[obj[0]] = parseFloat(obj[1]);
                }
            }
            context.skipCount = 0;
            context.lastEventUpdateId = depth.u;
            context.lastEventUpdateTime = depth.E;
        };

        // This now conforms 100% to the Binance docs constraints on managing a local order book
        if (context.lastEventUpdateId) {
            const expectedUpdateId = context.lastEventUpdateId + 1;
            if (depth.U <= expectedUpdateId) {
                updateDepthCache();
            } else {
                let msg = 'depthHandler: [' + symbol + '] The depth cache is out of sync.';
                msg += ' Symptom: Unexpected Update ID. Expected "' + expectedUpdateId + '", got "' + depth.U + '"';
                if (App.options.verbose) log(msg);
                throw new Error(msg);
            }
        } else if (depth.U > context.snapshotUpdateId + 1) {
            /* In this case we have a gap between the data of the stream and the snapshot.
               This is an out of sync error, and the connection must be torn down and reconnected. */
            let msg = 'depthHandler: [' + symbol + '] The depth cache is out of sync.';
            msg += ' Symptom: Gap between snapshot and first stream data.';
            if (App.options.verbose) log(msg);
            throw new Error(msg);
        } else if (depth.u < context.snapshotUpdateId + 1) {
            /* In this case we've received data that we've already had since the snapshot.
               This isn't really an issue, and we can just update the cache again, or ignore it entirely. */

            // do nothing
        } else {
            // This is our first legal update from the stream data
            updateDepthCache();
        }
    };

    /**
     * Gets depth cache for given symbol
     * @param {string} symbol - the symbol to fetch
     * @return {object} - the depth cache object
     */
    const getDepthCache = function (symbol) {
        if (typeof App.depthCache[symbol] === 'undefined') return { bids: {}, asks: {} };
        return App.depthCache[symbol];
    };

    /**
     * Checks whether or not an array contains any duplicate elements
     *  Note(keith1024): at the moment this only works for primitive types,
     *  will require modification to work with objects
     * @param {array} array - the array to check
     * @return {boolean} - true or false
     */
    const isArrayUnique = function (array) {
        let s = new Set(array);
        return s.size === array.length;
    };





    return {

        /**
        * Gets depth cache for given symbol
        * @param {symbol} symbol - get depch cache for this symbol
        * @return {object} - object
        */
        depthCache: function (symbol) {
            return getDepthCache(symbol);
        },

        /**
        * Count decimal places
        * @param {float} float - get the price precision point
        * @return {int} - number of place
        */
        getPrecision: function (float) {
            if ( !float || Number.isInteger( float ) ) return 0;
            return float.toString().split('.')[1].length || 0;
        },

        /**
        * rounds number with given step
        * @param {float} qty - quantity to round
        * @param {float} stepSize - stepSize as specified by exchangeInfo
        * @return {float} - number
        */
        roundStep: function (qty, stepSize) {
            // Integers do not require rounding
            if (Number.isInteger(qty)) return qty;
            const qtyString = qty.toFixed(16);
            const desiredDecimals = Math.max(stepSize.indexOf('1') - 1, 0);
            const decimalIndex = qtyString.indexOf('.');
            return parseFloat(qtyString.slice(0, decimalIndex + desiredDecimals + 1));
        },

        /**
        * rounds price to required precision
        * @param {float} price - price to round
        * @param {float} tickSize - tickSize as specified by exchangeInfo
        * @return {float} - number
        */
        roundTicks: function (price, tickSize) {
            const formatter = new Intl.NumberFormat('en-US', { style: 'decimal', minimumFractionDigits: 0, maximumFractionDigits: 8 });
            const precision = formatter.format(tickSize).split('.')[1].length || 0;
            if (typeof price === 'string') price = parseFloat(price);
            return price.toFixed(precision);
        },

        /**
        * Gets percentage of given numbers
        * @param {float} min - the smaller number
        * @param {float} max - the bigger number
        * @param {int} width - percentage width
        * @return {float} - percentage
        */
        percent: function (min, max, width = 100) {
            return (min * 0.01) / (max * 0.01) * width;
        },

        /**
        * Gets the sum of an array of numbers
        * @param {array} array - the number to add
        * @return {float} - sum
        */
        sum: function (array) {
            return array.reduce((a, b) => a + b, 0);
        },

        /**
        * Reverses the keys of an object
        * @param {object} object - the object
        * @return {object} - the object
        */
        reverse: function (object) {
            let range = Object.keys(object).reverse(), output = {};
            for (let price of range) {
                output[price] = object[price];
            }
            return output;
        },

        /**
        * Converts an object to an array
        * @param {object} obj - the object
        * @return {array} - the array
        */
        array: function (obj) {
            return Object.keys(obj).map(function (key) {
                return [Number(key), obj[key]];
            });
        },

        /**
        * Sorts bids
        * @param {string} symbol - the object
        * @param {int} max - the max number of bids
        * @param {string} baseValue - the object
        * @return {object} - the object
        */
        sortBids: function (symbol, max = Infinity, baseValue = false) {
            let object = {}, count = 0, cache;
            if (typeof symbol === 'object') cache = symbol;
            else cache = getDepthCache(symbol).bids;
            let sorted = Object.keys(cache).sort(function (a, b) {
                return parseFloat(b) - parseFloat(a)
            });
            let cumulative = 0;
            for (let price of sorted) {
                if (baseValue === 'cumulative') {
                    cumulative += parseFloat(cache[price]);
                    object[price] = cumulative;
                } else if (!baseValue) object[price] = parseFloat(cache[price]);
                else object[price] = parseFloat((cache[price] * parseFloat(price)).toFixed(8));
                if (++count >= max) break;
            }
            return object;
        },

        /**
        * Sorts asks
        * @param {string} symbol - the object
        * @param {int} max - the max number of bids
        * @param {string} baseValue - the object
        * @return {object} - the object
        */
        sortAsks: function (symbol, max = Infinity, baseValue = false) {
            let object = {}, count = 0, cache;
            if (typeof symbol === 'object') cache = symbol;
            else cache = getDepthCache(symbol).asks;
            let sorted = Object.keys(cache).sort(function (a, b) {
                return parseFloat(a) - parseFloat(b);
            });
            let cumulative = 0;
            for (let price of sorted) {
                if (baseValue === 'cumulative') {
                    cumulative += parseFloat(cache[price]);
                    object[price] = cumulative;
                } else if (!baseValue) object[price] = parseFloat(cache[price]);
                else object[price] = parseFloat((cache[price] * parseFloat(price)).toFixed(8));
                if (++count >= max) break;
            }
            return object;
        },

        /**
        * Returns the first property of an object
        * @param {object} object - the object to get the first member
        * @return {string} - the object key
        */
        first: function (object) {
            return Object.keys(object).shift();
        },

        /**
        * Returns the last property of an object
        * @param {object} object - the object to get the first member
        * @return {string} - the object key
        */
        last: function (object) {
            return Object.keys(object).pop();
        },

        /**
        * Returns an array of properties starting at start
        * @param {object} object - the object to get the properties form
        * @param {int} start - the starting index
        * @return {array} - the array of entires
        */
        slice: function (object, start = 0) {
            return Object.entries(object).slice(start).map(entry => entry[0]);
        },

        /**
        * Gets the minimum key form object
        * @param {object} object - the object to get the properties form
        * @return {string} - the minimum key
        */
        min: function (object) {
            return Math.min.apply(Math, Object.keys(object));
        },

        /**
        * Gets the maximum key form object
        * @param {object} object - the object to get the properties form
        * @return {string} - the minimum key
        */
        max: function (object) {
            return Math.max.apply(Math, Object.keys(object));
        },

        /**
        * Gets an option given a key
        * @param {object} opt - the object with the class configuration
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        options: function (opt, callback = false) {
            if (typeof opt === 'string') { // Pass json config filename
                App.options = JSON.parse(file.readFileSync(opt));
            } else App.options = opt;
            if (typeof App.options.recvWindow === 'undefined') App.options.recvWindow = default_options.recvWindow;
            if (typeof App.options.useServerTime === 'undefined') App.options.useServerTime = default_options.useServerTime;
            if (typeof App.options.reconnect === 'undefined') App.options.reconnect = default_options.reconnect;
            if (typeof App.options.test === 'undefined') App.options.test = default_options.test;
            if (typeof log === 'undefined') log = default_options.log;
            if (typeof App.options.verbose === 'undefined') App.options.verbose = default_options.verbose;
            if (App.options.useServerTime) {
                apiRequest('v1/common/timestamp', {}, function (error, response) {
                    App.info.timeOffset = response.data - new Date().getTime();
                    //log("server time set: ", response.serverTime, App.info.timeOffset);
                    if (callback) callback();
                });
            } else if (callback) callback();
            return this;
        },


        /**
        * Creates an order
        * @param {string} side - BUY or SELL
        * @param {string} symbol - the symbol to buy
        * @param {numeric} quantity - the quantity required
        * @param {numeric} price - the price to pay for each unit
        * @param {object} flags - aadditionalbuy order flags
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        order: function (side, symbol, quantity, price, flags = {}, callback = false) {
            order(side, symbol, quantity, price, flags, callback);
        },

        /**
        * Creates a buy order
        * @param {string} symbol - the symbol to buy
        * @param {numeric} quantity - the quantity required
        * @param {numeric} price - the price to pay for each unit
        * @param {object} flags - additional buy order flags
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        buy: function (symbol, quantity, price, flags = {}, callback = false) {
            order('buy', symbol, quantity, price, flags, callback);
        },

        /**
        * Creates a sell order
        * @param {string} symbol - the symbol to sell
        * @param {numeric} quantity - the quantity required
        * @param {numeric} price - the price to sell each unit for
        * @param {object} flags - additional order flags
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        sell: function (symbol, quantity, price, flags = {}, callback = false) {
            order('sell', symbol, quantity, price, flags, callback);
        },

        /**
        * Cancels an order
        * @param {string} symbol - the symbol to cancel
        * @param {string} orderid - the orderid to cancel
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        cancel: function (symbol, orderid, callback = false) {
            signedRequest(`v1/order/orders/${orderid}/submitcancel`, { symbol: symbol, orderId: orderid }, function (error, data) {
                if (callback) return callback.call(this, error, data, symbol);
            }, 'POST');
        },

        /**
        * Gets the status of an order
        * @param {string} symbol - the symbol to check
        * @param {string} orderid - the orderid to check
        * @param {function} callback - the callback function
        * @param {object} flags - any additional flags
        * @return {undefined}
        */
        orderStatus: function (symbol, orderid, callback, flags = {}) {
            let parameters = Object.assign({ symbol: symbol, orderId: orderid }, flags);

            signedRequest(`v1/order/orders/${orderid}`, parameters, function (error, data) {
                if (callback) return callback.call(this, error, data, symbol);
            });
        },

        /**
        * Gets open orders
        * @param {string} symbol - the symbol to get
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        openOrders: function (symbol, callback) {
            let parameters = symbol ? { symbol: symbol } : {};
            signedRequest('v1/order/openOrders', parameters, function (error, data) {
                return callback.call(this, error, data, symbol);
            });
        },

        /**
        * Gets the depth information for a given symbol
        * @param {string} symbol - the symbol
        * @param {function} callback - the callback function
        * @param {int} limit - limit the number of returned orders
        * @return {undefined}
        */
        depth: function (symbol, callback, limit = 100) {
            publicRequest('v1/market/depth', { symbol: symbol, depth: limit }, function (error, data) {
                return callback.call(this, error, depthData(data), symbol);
            });
        },


        /**
         *  
        * Gets the prices of a given symbol(s)
        * @param {string} symbol - the symbol
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        prices: function (symbol, callback = false) {//TODO
            const params = typeof symbol === 'string' ? '?symbol=' + symbol : '';
            if (typeof symbol === 'function') callback = symbol; // backwards compatibility

            let opt = {
                url: base + 'v3/ticker/price' + params,
                timeout: App.options.recvWindow
            };

            request(addProxy(opt), function (error, response, body) {
                if (!callback) return;

                if (error) return callback(error);

                if (response && response.statusCode !== 200) return callback(response);

                if (callback) return callback(null, priceData(JSON.parse(body)));
            });
        },

        /**
        * Gets the book tickers of given symbol(s)
        * @param {string} symbol - the symbol
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        bookTickers: function (callback) {
            let opt = {
                url: base + 'market/tickers',
                timeout: App.options.recvWindow
            };

            request(addProxy(opt), function (error, response, body) {
                if (!callback) return;

                if (error) return callback(error);

                if (response && response.statusCode !== 200) return callback(response);

                if (callback) {
                    const result = JSON.parse( body );
                    return callback(null, result.data);
                }
            });
        },

        /**
        * Gets the the exchange info
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        exchangeInfo: function (callback) {
            publicRequest('v1/common/symbols', {}, callback);
        },

        /**
        * Get the balance data
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        balance: function (callback) {
            signedRequest(`v1/account/accounts/${App.options.account_id}/balance`, {}, function (error, data) {
                if (callback) callback(error, balanceData(data.data.list));
            });
        },

        /**
        * Get trades for a given symbol
        * @param {string} symbol - the symbol
        * @param {function} callback - the callback function
        * @param {object} options - additional options
        * @return {undefined}
        */
        trades: function (symbol, callback, options = {}) {
            let parameters = Object.assign({ symbol: symbol }, options);
            signedRequest('market/history/trade', parameters, function (error, data) {
                if (callback) return callback.call(this, error, data, symbol);
            });
        },

        /**
        * Tell api to use the server time to offset time indexes
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        useServerTime: function (callback = false) {
            apiRequest('v1/time', {}, function (error, response) {
                App.info.timeOffset = response.serverTime - new Date().getTime();
                //log("server time set: ", response.serverTime, App.info.timeOffset);
                if (callback) callback();
            });
        },

        /**
        * Gets the time
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        time: function (callback) {
            apiRequest('v1/time', {}, callback);
        },

        /**
        * Get agg trades for given symbol
        * @param {string} symbol - the symbol
        * @param {object} options - addtional optoins
        * @param {function} callback - the callback function
        * @return {undefined}
        */
        aggTrades: function (symbol, options = {}, callback = false) { //fromId startTime endTime limit
            let parameters = Object.assign({ symbol }, options);
            marketRequest(base + 'v1/aggTrades', parameters, callback);
        },

        /**
        * Get the recent trades
        * @param {string} symbol - the symbol
        * @param {function} callback - the callback function
        * @param {int} limit - limit the number of items returned
        * @return {undefined}
        */
        recentTrades: function (symbol, callback, limit = 500) {
            marketRequest(base + 'v1/trades', { symbol: symbol, limit: limit }, callback);
        },

        /**
        * Get the historical trade info
        * @param {string} symbol - the symbol
        * @param {function} callback - the callback function
        * @param {int} limit - limit the number of items returned
        * @param {int} fromId - from this id
        * @return {undefined}
        */
        historicalTrades: function (symbol, callback, limit = 500, fromId = false) {
            let parameters = { symbol: symbol, limit: limit };
            if (fromId) parameters.fromId = fromId;
            marketRequest(base + 'v1/historicalTrades', parameters, callback);
        },

        /**
        * Convert chart data to highstock array [timestamp,open,high,low,close]
        * @param {object} chart - the chart
        * @param {boolean} include_volume - to include the volume or not
        * @return {array} - an array
        */
        highstock: function (chart, include_volume = false) {
            let array = [];
            for (let timestamp in chart) {
                let obj = chart[timestamp];
                let line = [
                    Number(timestamp),
                    parseFloat(obj.open),
                    parseFloat(obj.high),
                    parseFloat(obj.low),
                    parseFloat(obj.close)
                ];
                if (include_volume) line.push(parseFloat(obj.volume));
                array.push(line);
            }
            return array;
        },

        /**
        * Populates hte OHLC information
        * @param {object} chart - the chart
        * @return {object} - object with candle information
        */
        ohlc: function (chart) {
            let open = [], high = [], low = [], close = [], volume = [];
            for (let timestamp in chart) { //App.ohlc[symbol][interval]
                let obj = chart[timestamp];
                open.push(parseFloat(obj.open));
                high.push(parseFloat(obj.high));
                low.push(parseFloat(obj.low));
                close.push(parseFloat(obj.close));
                volume.push(parseFloat(obj.volume));
            }
            return { open, high, low, close, volume };
        },

        /**
        * Gets the candles information for a given symbol
        * intervals: 1min, 5min, 15min, 30min, 60min, 1day, 1mon, 1week, 1year
        * @param {string} symbol - the symbol
        * @param {function} interval - the callback function
        * @param {function} callback - the callback function
        * @param {object} options - additional options
        * @return {undefined}
        */
        candlesticks: function (symbol, interval = '5min', callback = false, options = { size: 500 }) {
            if (!callback) return;
            let params = Object.assign({ symbol: symbol, period: interval }, options);
            publicRequest('market/history/kline', params, function (error, data) {
                try {
                    callback.call(this, error, data, symbol);
                } catch (error) {
                    log(error);
                }
            });
        },

        /**
        * Queries the public api
        * @param {string} url - the public api endpoint
        * @param {object} data - the data to send
        * @param {function} callback - the callback function
        * @param {string} method - the http method
        * @return {undefined}
        */
        publicRequest: function (url, data, callback, method = 'GET') {
            publicRequest(url, data, callback, method)
        },

        /**
        * Queries the signed api
        * @param {string} url - the signed api endpoint
        * @param {object} data - the data to send
        * @param {function} callback - the callback function
        * @param {string} method - the http method
        * @return {undefined}
        */
        signedRequest: function (endpoint, data, callback, method = 'GET') {
            signedRequest(endpoint, data, callback, method);
        },

        /**
        * Gets the market asset of given symbol
        * @param {string} symbol - the public api endpoint
        * @return {undefined}
        */
        getMarket: function (symbol) {
            const substring = symbol.substr(-3);
            if (substring === 'BTC') return 'BTC';
            else if (substring === 'ETH') return 'ETH';
            else if (substring === 'BNB') return 'BNB';
            else if (symbol.substr(-4) === 'USDT') return 'USDT';
        },
        websockets: {
            /**
            * Userdata websockets function
            * @param {function} callback - the callback function
            * @param {function} execution_callback - optional execution callback
            * @param {function} subscribed_callback - subscription callback
            * @return {undefined}
            */
            userData: function userData(callback, execution_callback = false, subscribed_callback = false) {
                let reconnect = function () {
                    if (App.options.reconnect) userData(callback, execution_callback, subscribed_callback);
                };
                apiRequest('v1/userDataStream', {}, function (error, response) {
                    App.options.listenKey = response.listenKey;
                    setTimeout(function userDataKeepAlive() { // keepalive
                        try {
                            apiRequest('v1/userDataStream?listenKey=' + App.options.listenKey, {}, function (err) {
                                if (err) setTimeout(userDataKeepAlive, 60000); // retry in 1 minute
                                else setTimeout(userDataKeepAlive, 60 * 30 * 1000); // 30 minute keepalive
                            }, 'PUT');
                        } catch (error) {
                            setTimeout(userDataKeepAlive, 60000); // retry in 1 minute
                        }
                    }, 60 * 30 * 1000); // 30 minute keepalive
                    App.options.balance_callback = callback;
                    App.options.execution_callback = execution_callback;
                    const subscription = subscribe(App.options.listenKey, userDataHandler, reconnect);
                    if (subscribed_callback) subscribed_callback(subscription.endpoint);
                }, 'POST');
            },

            /**
            * Subscribe to a generic websocket
            * @param {string} url - the websocket endpoint
            * @param {function} callback - optional execution callback
            * @param {boolean} reconnect - subscription callback
            * @return {WebSocket} the websocket reference
            */
            subscribe: function (url, callback, reconnect = false) {
                return subscribe(url, callback, reconnect);
            },

            /**
            * Subscribe to a generic combined websocket
            * @param {string} url - the websocket endpoint
            * @param {function} callback - optional execution callback
            * @param {boolean} reconnect - subscription callback
            * @return {WebSocket} the websocket reference
            */
            subscribeCombined: function (url, callback, reconnect = false) {
                return subscribeCombined(url, callback, reconnect);
            },

            /**
            * Returns the known websockets subscriptions
            * @return {array} array of web socket subscriptions
            */
            subscriptions: function () {
                return App.subscriptions;
            },

            /**
            * Terminates a web socket
            * @param {string} endpoint - the string associated with the endpoint
            * @return {undefined}
            */
            terminate: function (endpoint) {
                if (App.options.verbose) log('WebSocket terminating:', endpoint);
                return terminate(endpoint);
            },

            /**
            * Websocket depth chart
            * @param {array/string} symbols - an array or string of symbols to query
            * @param {function} callback - callback function
            * @return {string} the websocket endpoint
            */
            depth: function depth(symbols, callback) {
                let reconnect = function () {
                    if (App.options.reconnect) depth(symbols, callback);
                };

                let subscription;
                if (Array.isArray(symbols)) {
                    if (!isArrayUnique(symbols)) throw Error('depth: "symbols" cannot contain duplicate elements.');
                    let streams = symbols.map(function (symbol) {
                        return symbol.toLowerCase() + '@depth';
                    });
                    subscription = subscribeCombined(streams, callback, reconnect);
                } else {
                    let symbol = symbols;
                    subscription = subscribe(symbol.toLowerCase() + '@depth', callback, reconnect);
                }
                return subscription.endpoint;
            },

            /**
            * Websocket depth cache
            * @param {array/string} symbols - an array or string of symbols to query
            * @param {function} callback - callback function
            * @param {int} limit - the number of entries
            * @return {string} the websocket endpoint
            */
            depthCache: function depthCacheFunction(symbols, callback, limit = 500) {
                let reconnect = function () {
                    if (App.options.reconnect) depthCacheFunction(symbols, callback, limit);
                };

                let symbolDepthInit = function (symbol) {
                    if (typeof App.depthCacheContext[symbol] === 'undefined') App.depthCacheContext[symbol] = {};

                    let context = App.depthCacheContext[symbol];
                    context.snapshotUpdateId = null;
                    context.lastEventUpdateId = null;
                    context.messageQueue = [];

                    App.depthCache[symbol] = { bids: {}, asks: {} };
                };

                let assignEndpointIdToContext = function (symbol, endpointId) {
                    if (App.depthCacheContext[symbol]) {
                        let context = App.depthCacheContext[symbol];
                        context.endpointId = endpointId;
                    }
                };

                let handleDepthStreamData = function (depth) {
                    let symbol = depth.s;
                    let context = App.depthCacheContext[symbol];
                    if (context.messageQueue && !context.snapshotUpdateId) {
                        context.messageQueue.push(depth);
                    } else {
                        try {
                            depthHandler(depth);
                        } catch (err) {
                            return terminate(context.endpointId, true);
                        }
                        if (callback) callback(symbol, App.depthCache[symbol], context);
                    }
                };

                let getSymbolDepthSnapshot = function (symbol, cb) {

                    publicRequest('v1/depth', { symbol: symbol, limit: limit }, function (error, json) {
                        if (error) {
                            return cb(error, null);
                        }
                        // Store symbol next use
                        json.symb = symbol;
                        cb(null, json)
                    });
                };

                let updateSymbolDepthCache = function (json) {
                    // Get previous store symbol
                    let symbol = json.symb;
                    // Initialize depth cache from snapshot
                    App.depthCache[symbol] = depthData(json);
                    // Prepare depth cache context
                    let context = App.depthCacheContext[symbol];
                    context.snapshotUpdateId = json.lastUpdateId;
                    if (typeof context.messageQueue != 'undefined') {
                    	context.messageQueue = context.messageQueue.filter(depth => depth.u > context.snapshotUpdateId);
	                    // Process any pending depth messages
	                    for (let depth of context.messageQueue) {

	                        /* Although sync errors shouldn't ever happen here, we catch and swallow them anyway
	                           just in case. The stream handler function above will deal with broken caches. */
	                        try {
	                            depthHandler(depth);
	                        } catch (err) {
	                            // do nothing
	                        }
	                    }
	                    delete context.messageQueue;
	                }
                    if (callback) callback(symbol, App.depthCache[symbol]);
                };

                /* If an array of symbols are sent we use a combined stream connection rather.
                   This is transparent to the developer, and results in a single socket connection.
                   This essentially eliminates "unexpected response" errors when subscribing to a lot of data. */
                let subscription;
                if (Array.isArray(symbols)) {
                    if (!isArrayUnique(symbols)) throw Error('depthCache: "symbols" cannot contain duplicate elements.');

                    symbols.forEach(symbolDepthInit);
                    let streams = symbols.map(function (symbol) {
                        return symbol.toLowerCase() + '@depth';
                    });
                    subscription = subscribeCombined(streams, handleDepthStreamData, reconnect, function () {
                        async.mapLimit(symbols, 50, getSymbolDepthSnapshot, (err, results) => {
                            if (err) { log(err); throw err; }
                            results.forEach(updateSymbolDepthCache);
                        });
                    });
                    symbols.forEach(s => assignEndpointIdToContext(s, subscription.endpoint));
                } else {
                    let symbol = symbols;
                    symbolDepthInit(symbol);
                    subscription = subscribe(symbol.toLowerCase() + '@depth', handleDepthStreamData, reconnect, function () {
                        async.mapLimit([symbol], 1, getSymbolDepthSnapshot, (err, results) => {
                            if (err) throw err;
                            results.forEach(updateSymbolDepthCache);
                        });
                    });
                    assignEndpointIdToContext(symbol, subscription.endpoint);
                }
                return subscription.endpoint;
            },

            /**
             * Clear websocket depthcache
             * @param {String|Array} symbols   - a single symbol, or an array of symbols, to clear the cache of
             */
            clearDepthCache(symbols) {
                const symbolsArr = Array.isArray(symbols) ? symbols : [symbols];
                symbolsArr.forEach((thisSymbol) => {
                    delete App.depthCache[thisSymbol];
                });
            },

            /**
             * Websocket staggered depth cache
             * @param {array/string} symbols - an array of symbols to query
             * @param {function} callback - callback function
             * @param {int} limit - the number of entries
             * @param {int} stagger - ms between each depth cache
             * @return {Promise} the websocket endpoint
             */
            depthCacheStaggered: function (symbols, callback, limit = 100, stagger = 200) {
                if (!Array.isArray(symbols)) symbols = [symbols];
                let chain = null;

                symbols.forEach(symbol => {
                    let promise = () => new Promise(resolve => {
                        this.depthCache(symbol, callback, limit);
                        setTimeout(resolve, stagger);
                    });
                    chain = chain ? chain.then(promise) : promise();
                });

                return chain;
            },

            /**
            * Websocket aggregated trades
            * @param {array/string} symbols - an array or string of symbols to query
            * @param {function} callback - callback function
            * @return {string} the websocket endpoint
            */
            aggTrades: function trades(symbols, callback) {
                let reconnect = function () {
                    if (App.options.reconnect) trades(symbols, callback);
                };

                let subscription;
                if (Array.isArray(symbols)) {
                    if (!isArrayUnique(symbols)) throw Error('trades: "symbols" cannot contain duplicate elements.');
                    let streams = symbols.map(function (symbol) {
                        return symbol.toLowerCase() + '@aggTrade';
                    });
                    subscription = subscribeCombined(streams, callback, reconnect);
                } else {
                    let symbol = symbols;
                    subscription = subscribe(symbol.toLowerCase() + '@aggTrade', callback, reconnect);
                }
                return subscription.endpoint;
            },

            /**
            * Websocket raw trades
            * @param {array/string} symbols - an array or string of symbols to query
            * @param {function} callback - callback function
            * @return {string} the websocket endpoint
            */
            trades: function trades(symbols, callback) {
                let reconnect = function () {
                    if (App.options.reconnect) trades(symbols, callback);
                };

                let subscription;
                if (Array.isArray(symbols)) {
                    if (!isArrayUnique(symbols)) throw Error('trades: "symbols" cannot contain duplicate elements.');
                    let streams = symbols.map(function (symbol) {
                        return symbol.toLowerCase() + '@trade';
                    });
                    subscription = subscribeCombined(streams, callback, reconnect);
                } else {
                    let symbol = symbols;
                    subscription = subscribe(symbol.toLowerCase() + '@trade', callback, reconnect);
                }
                return subscription.endpoint;
            },

            /**
            * Websocket klines
            * @param {array/string} symbols - an array or string of symbols to query
            * @param {string} interval - the time interval
            * @param {function} callback - callback function
            * @param {int} limit - maximum results, no more than 1000
            * @return {string} the websocket endpoint
            */
            chart: function chart(symbols, interval, callback, limit = 500) {
                let reconnect = function () {
                    if (App.options.reconnect) chart(symbols, interval, callback, limit);
                };

                let symbolChartInit = function (symbol) {
                    if (typeof App.info[symbol] === 'undefined') App.info[symbol] = {};
                    if (typeof App.info[symbol][interval] === 'undefined') App.info[symbol][interval] = {};
                    if (typeof App.ohlc[symbol] === 'undefined') App.ohlc[symbol] = {};
                    if (typeof App.ohlc[symbol][interval] === 'undefined') App.ohlc[symbol][interval] = {};
                    if (typeof App.ohlcLatest[symbol] === 'undefined') App.ohlcLatest[symbol] = {};
                    if (typeof App.ohlcLatest[symbol][interval] === 'undefined') App.ohlcLatest[symbol][interval] = {};
                    if (typeof App.klineQueue[symbol] === 'undefined') App.klineQueue[symbol] = {};
                    if (typeof App.klineQueue[symbol][interval] === 'undefined') App.klineQueue[symbol][interval] = [];
                    App.info[symbol][interval].timestamp = 0;
                }

                let handleKlineStreamData = function (kline) {
                    let symbol = kline.s;
                    if (!App.info[symbol][interval].timestamp) {
                        if (typeof (App.klineQueue[symbol][interval]) !== 'undefined' && kline !== null) {
                            App.klineQueue[symbol][interval].push(kline);
                        }
                    } else {
                        //log('@klines at ' + kline.k.t);
                        klineHandler(symbol, kline);
                        if (callback) callback(symbol, interval, klineConcat(symbol, interval));
                    }
                };

                let getSymbolKlineSnapshot = function (symbol, limit = 500) {
                    publicRequest('v1/klines', { symbol: symbol, interval: interval, limit: limit }, function (error, data) {
                        klineData(symbol, interval, data);
                        //log('/klines at ' + App.info[symbol][interval].timestamp);
                        if (typeof App.klineQueue[symbol][interval] !== 'undefined') {
                            for (let kline of App.klineQueue[symbol][interval]) klineHandler(symbol, kline, App.info[symbol][interval].timestamp);
                            delete App.klineQueue[symbol][interval];
                        }
                        if (callback) callback(symbol, interval, klineConcat(symbol, interval));
                    });
                };

                let subscription;
                if (Array.isArray(symbols)) {
                    if (!isArrayUnique(symbols)) throw Error('chart: "symbols" cannot contain duplicate elements.');
                    symbols.forEach(symbolChartInit);
                    let streams = symbols.map(function (symbol) {
                        return symbol.toLowerCase() + '@kline_' + interval;
                    });
                    subscription = subscribeCombined(streams, handleKlineStreamData, reconnect);
                    symbols.forEach(element => getSymbolKlineSnapshot(element, limit));
                } else {
                    let symbol = symbols;
                    symbolChartInit(symbol);
                    subscription = subscribe(symbol.toLowerCase() + '@kline_' + interval, handleKlineStreamData, reconnect);
                    getSymbolKlineSnapshot(symbol, limit);
                }
                return subscription.endpoint;
            },

            /**
            * Websocket candle sticks
            * @param {array/string} symbols - an array or string of symbols to query
            * @param {string} interval - the time interval
            * @param {function} callback - callback function
            * @return {string} the websocket endpoint
            */
            candlesticks: function candlesticks(symbols, interval, callback) {
                let reconnect = function () {
                    if (App.options.reconnect) candlesticks(symbols, interval, callback);
                };

                /* If an array of symbols are sent we use a combined stream connection rather.
                   This is transparent to the developer, and results in a single socket connection.
                   This essentially eliminates "unexpected response" errors when subscribing to a lot of data. */
                let subscription;
                if (Array.isArray(symbols)) {
                    if (!isArrayUnique(symbols)) throw Error('candlesticks: "symbols" cannot contain duplicate elements.');
                    let streams = symbols.map(function (symbol) {
                        return symbol.toLowerCase() + '@kline_' + interval;
                    });
                    subscription = subscribeCombined(streams, callback, reconnect);
                } else {
                    let symbol = symbols.toLowerCase();
                    subscription = subscribe(symbol + '@kline_' + interval, callback, reconnect);
                }
                return subscription.endpoint;
            },

            /**
            * Websocket mini ticker
            * @param {function} callback - callback function
            * @return {string} the websocket endpoint
            */
            miniTicker: function miniTicker(callback) {
                let reconnect = function () {
                    if (App.options.reconnect) miniTicker(callback);
                };
                let subscription = subscribe('!miniTicker@arr', function (body) {
                    const result = JSON.parse( body );
                    data = result.data;
                    let markets = {};
                    for (let obj of data) {
                        markets[obj.s] = {
                            close: obj.c,
                            open: obj.o,
                            high: obj.h,
                            low: obj.l,
                            volume: obj.v,
                            quoteVolume: obj.q,
                            eventTime: obj.E
                        };
                    }
                    callback(markets);
                }, reconnect);
                return subscription.endpoint;
            },

            /**
            * Websocket prevday percentage
            * @param {array/string} symbols - an array or string of symbols to query
            * @param {function} callback - callback function
            * @param {boolean} singleCallback - avoid call one callback for each symbol in data array
            * @return {string} the websocket endpoint
            */
            prevDay: function prevDay(symbols, callback, singleCallback) {
                let reconnect = function () {
                    if (App.options.reconnect) prevDay(symbols, callback);
                };

                let subscription;
                // Combine stream for array of symbols
                if (Array.isArray(symbols)) {
                    if (!isArrayUnique(symbols)) throw Error('prevDay: "symbols" cannot contain duplicate elements.');
                    let streams = symbols.map(function (symbol) {
                        return typeof symbol != 'undefined' ? symbol.toLowerCase() + '@ticker' : '';
                    });
                    subscription = subscribeCombined(streams, function (data) {
                        prevDayStreamHandler(data, callback);
                    }, reconnect);
                    // Raw stream for  a single symbol
                } else if (symbols) {
                    let symbol = symbols;
                    subscription = subscribe(symbol.toLowerCase() + '@ticker', function (data) {
                        prevDayStreamHandler(data, callback);
                    }, reconnect);
                    // Raw stream of all listed symbols
                } else {
                    subscription = subscribe('!ticker@arr', function (data) {
                        if (singleCallback) {
                            prevDayStreamHandler(data, callback);
                        } else {
                            for (let line of data) {
                                prevDayStreamHandler(line, callback);
                            }
                        }
                    }, reconnect);
                }
                return subscription.endpoint;
            }
        }
    };
}
module.exports = api;
//https://github.com/binance-exchange/binance-official-api-docs
